(* This is a EBNF file for Esolang uncle lang, inspired from Japan's Ojisan koubun,
the source will be encoded with UTF-8 and each symbol the language used will be in Traditional chinese or emoji*)

(* Greeting - can also be use as comment, do not affect the logic but count in grammar.
Parser will check if specified item need to start with greeting otherwise just skip it as comment.
string_char part can be any messages, use to let the code reads like an actual paragraph 
*)

greet_parenthesis = "â¤" | "ğŸ˜˜" | "ğŸ¥º" | "ğŸ˜ˆ" | "ğŸ˜¥" | "ğŸ’" ;
greeting = greet_parenthesis greeting_char greet_parenthesis

(* Program Structure *)
program = { statement } ;

(* Statements *)
(* For statement separator use "ğŸ’¦" instead of ";" *)
statement = assignment
          | if_statement
          | print_statement
          | expression 
          | declaration;

assignment = greeting identifier { index_access } "æ˜¯" expression "ğŸ’¦" ;

declaration = greeting "è·Ÿä½ èªª" identifier [ "æ˜¯" expression ] "ğŸ’¦" ;

if_statement = greeting "å¦‚æœ" "ğŸ‘‰" condition "ğŸ‘ˆ" block
               [ "ä¹Ÿå¯èƒ½" "ğŸ‘‰" condition "ğŸ‘ˆ" block ] 
               [ "ä¸ç„¶å°±" block ];

(* A block must contain polite statements *)
block = "ğŸ‘†" { statement } "ğŸ‘‡" ;

(* Conditions - now supports boolean expressions *)
condition = logical_or ;
// ... (rest of the file is unchanged) ...

logical_or = logical_and { "æˆ–æ˜¯" logical_and } ;

logical_and = comparison { "è€Œä¸”" comparison } ;

comparison = expression [ comparison_op expression ]
           | "âŒ" comparison ;

comparison_op = "ç­‰æ–¼" | "âŒç­‰æ–¼" | "å°æ–¼" | "å¤§æ–¼" | "å°æ–¼ç­‰æ–¼" | "å¤§æ–¼ç­‰æ–¼" ;

(* Expressions with operator precedence *)
expression = term { ("åŠ ä¸Š" | "æ¸›æ‰") term } ;

term = factor { ("ä¹˜" | "é™¤" | "å–é¤˜æ•¸") factor } ;

factor = number
       | boolean
       | string
       | vector_literal
       | identifier [ index_access ]
       | "ğŸ‘‰" expression "ğŸ‘ˆ"
       | "ğŸ‘‰" condition "ğŸ‘ˆ" ;

(* Vector and String Support *)
vector_literal = "ğŸ¤œ" [ expression { "ğŸŒŸ" expression } ] "ğŸ¤›" ;

index_access = "ğŸ¤œ" expression "ğŸ¤›" ;

(* Lexical Elements *)
boolean = "çœŸçš„" | "å‡çš„" ;

identifier = letter { letter | digit | "_" } ;

number = digit { digit } [ "." digit { digit } ] ;

letter = (Any UTF-8 supported symbol without digits)

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

string = 'ğŸ¤—' { string_char } 'ğŸ¤—' ;

string_char = letter
            | digit
            | " "
            | escape_sequence
            | (* any printable character except " and \ *) ;

(*greeting_char should contain "å¤§å”" *)
greeting_char = letter
            | digit
            | " "
            | escape_sequence
            | (* any printable character except " and \ *) ;

escape_sequence = "\" ( "n" | "t" | "r" | "\" | '"' ) ;


(* Special support *)
(* print function *)

print_statement = greeting "ğŸ¥°" expression  "ğŸ’¦" ;
 

